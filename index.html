<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>알고리즘</title>
  </head>
  <body>
    <script>
      // 재귀함수 사례 - 2진수 변환
      /*
        중고딩 때처럼 10진수 -> 2진수를 변환한다면

        나눠주는 값           나눠지는 값(몫)         나머지
        2                          11                    1   
        2                           5                    1
        2                           2                    0
                                    1
        -> 요렇게 구해준 다음 아래서부터 위로 나머지를 역순으로 읽어서
        1011(2) 요런 식으로 변형해줬지

        이거를 반복문 및 재귀함수를 사용해서 구해보도록 할거임.
      */
      // 반복문으로 구현하는 법
      let result = "";
      let x = 11; // 11을 이진수로 바꾸겠구나

      while (true) {
        // 기본적으로는 무한반복을 해주고 x는 나눠지는 값(몫) 에 해당하는 값들이 들어갈거임.
        if (x % 2 == 0) {
          // 만약, 2로 나눈 나머지가 0이라면, 문자열 '0'을 추가해주고,
          /*
            근데 result 를 이렇게 계산해줘버리면
            우리가 원하는 역순으로 읽는 값인 1011 가 아니라, 1101 이 출력되어버림.

            그래서, result 에 문자열을 추가해줄 때,
            result = '0' + result; 이런 식으로
            문자열을 삽입할 때마다 맨 첫번째 자리로 넣어줘야 함! 그래야 역순으로 읽히지!

            아래에 다른 공식들도 마찬가지로 해줄 것.
          */
          result += "0";
          // result = "0" + result;
        } else {
          // 2로 나눈 나머지가 0이 아니라면, (나머지는 0 아니면 1이니까) 문자열 '1' 을 추가해 줌.
          result += "1";
          // result = "1" + result;
        }

        x = Math.floor(x / 2); // 이거는 다음 반복문에서 몫(즉 나눠지는 값) 사용할 값을 미리 구해놓는 거
        /*
          이 세개는 캔버스 프로젝트에서 많이 해줬으니 잘 알거임.

          Math.ceil() : 소수점 올림
          Math.floor() : 소수점 버림
          Math.round() : 소수점 반올림

          이거는 왜 한번 정리해줬냐면
          정수 2로 나눴을 때 자바스크립트는
          나머지가 0이 아니면 소수점까지 몫을 계산해버리기 때문에
          소수점이 없는 상태의 정수값으로 몫을 변환해줘야 함.
          
          ->몫(정수부분) 외에 나머지 소수부분(나머지) 는 버려두 되니까
          Math.floor() 를 써야겠지?
        */

        if (x == 1 || x == 0) {
          // x(나눠지는 값, 몫)이 0 또는 1이 된다면 위에 주석에서 설명한 4번째 줄에 해당하는 상황이잖아.
          // 즉, 마지막 계산이라는 뜻이므로, 이 x값 자체를 문자열로 변환해서 result 에 추가해주라는 뜻.
          // 한마디로 얘는 반복문의 종결조건
          result += String(x);
          // result = String(x) + result;
          break; // 반복문 종결
        }
      }
      console.log(result.split("").reverse().join(""));
      /*
        result에 역순으로 문자열 추가하는 방법 외에 
        split과 reverse 배열 메서드를 이용하는 방법이 있음.

        split 은 구분자를 기준으로 문자열을 나눠서 배열로 리턴해 줌.
        reverse 는 그러한 배열 요소를 역순으로 반전해서 리턴해 줌.
        join 은 당연히 배열 요소들을 연결해서 하나의 문자열 덩어리로 리턴해주는 거고!
      */

      // 이번에는 재귀함수로 2진수 변환을 해보자
      let 결과값 = "";
      function 이진법(숫자) {
        if (숫자 == 1 || 숫자 == 0) {
          // 이것도 재귀함수의 종결조건이지?
          return String(숫자); // 여기서는 return 자체가 break 의 역할을 할테니 굳이 중복해서 안써줘도 되겠지
        }

        // 만약에 0, 1 이외의 숫자(몫) 이 들어왔다면?
        // 0 또는 1 인 나머지값의 문자열에다가 다음 나눠지는 값(즉 2로 나눈 몫)을 '이진법' 재귀함수에 전달하면서 호출!
        // 그리고 그 결과값이 될 문자열을 옆에다가 붙여주는 것이지! -> 1-100 까지 숫자 곱, 합 했을때랑 재귀함수 패턴이 유사하지?
        return 이진법(Math.floor(숫자 / 2)) + String(숫자 % 2);
      }

      결과값 = 이진법(11);

      // 위에 반복문에서 했던 것처럼 다 계산하고 이진수를 역순으로 뒤집어주는 작업을 마지막에 해주는거임!
      // console.log(결과값.split("").reverse().join(""));
      console.log(결과값); // 또는 그냥 처음부터 재귀함수에서 문자열들을 거꾸로 더해줘도 됨.
      /*
        이 재귀함수가 어떤 과정으로 이런 결과를 나오는지 설명하자면

        호출되는 이진법()함수         리턴값 
        이진법(11)                   이진법(5) + String(1) -> 101 + String(1) -> 결과적으로 1011 이 리턴되는 것!
        이진법(5)                    이진법(2) + String(1) -> 10 + String(1)
        이진법(2)                    이진법(1) + String(0) -> 1 + String(0)
        이진법(1)                    1 -> 얘는 재귀함수 종결조건에 의해 1이 문자열로 리턴됨
      */
    </script>
  </body>
</html>

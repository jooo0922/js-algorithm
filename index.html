<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>알고리즘</title>
  </head>
  <body>
    <script>
      // 트리와 그래프 (DFS, BFS 탐색 구현)
      // 연결리스트를 object 로 구현했듯 트리도 object 로 만들어보자
      // left, right 두 개의 링크밖에 없기 때문에 '이진트리'에 해당하겠지
      const tree = {
        root: {
          value: 5,
          left: {
            value: 3,
            left: {
              value: 1,
              left: null,
              right: null,
            },
            right: {
              value: 4,
              left: null,
              right: null,
            },
          },
          right: {
            value: 8,
            left: {
              value: 6,
              left: null,
              right: null,
            },
            right: {
              value: 2,
              left: null,
              right: null,
            },
          },
        },
      };

      // 만약에 여기서 특정 위치의 노드를 콘솔로 찍어보고 싶다면 연결리스트에서 했던 것처럼 하면 됨
      // 이런식으로 데이터를 꺼내고 삽입하고 삭제하는 기능을 만들고 싶은거임.
      console.log(tree.root.left.left.value);

      // 이것도 인제 연결리스트와 유사한 클래스 구조로 구현 가능함.
      // 연결리스트 클래스 구조에서 메서드를 가져와서 사용해도 무방할 정도로 거의 비슷함.
      class Node {
        constructor(data) {
          this.data = data;
          // this.child = []; 2개 이상의 자식노드가 배열로 저장되어야 한다면 더 이상 2진트리가 아닌 트리겠지!
          this.left = null;
          this.right = null; // 초기값은 이진트리의 양쪽 노드 모두 null로 해줌
        }
      }

      class Tree {
        constructor(data) {
          let init = new Node(data); // 초기화할 새로운 노드를 하나 만듦
          this.root = init; // 즉, 이진트리의 최상위 노드를 init 노드다 라고 할당한 것.
          this.데이터수 = 0;
        }

        // 현재 데이터수를 출력해주는 메서드
        length() {
          return this.데이터수;
        }

        // data 로 새로운 노드를 만들어서 현재 이진트리 구조 상에 알아서 추가해 주는 메서드.
        // 연결리스트와 달리 index가 필요없음. 이진트리니까 왼쪽 아니면 오른쪽인지 판단해서 꽂아주면 되는거니까.
        insert(data) {
          let 새로운노드 = new Node(data);
          let 순회용현재노드 = this.root; // 순회하면서 업데이트해줄 노드

          // 순회용현재노드가 존재한다면 계속 반복해줄 것
          while (순회용현재노드) {
            if (data === 순회용현재노드.data) {
              // 만약에 기존 이진트리 내에 존재하는 데이터와 중복된다면
              // 해당 데이터는 insert 하지 말도록 정책을 짠 것.
              // 왜냐면 일반적으로 이진트리는 부모노드보다 작거나 크거나로
              // 왼쪽/오른쪽을 판단해야 하니 같은 값이 존재하면 안되겠지
              return;
            }

            // 만약 부모노드의 데이터보다 작으면 왼쪽으로, 크면 오른쪽으로 자식노드를 달아줌.
            // 이렇게 해줘야 검색기능 같은 거에서 사용할 때 일반적인 배열같은 자료구조보다
            // 훨씬 더 빠르고 수월하게 원하는 데이터를 찾을 수 있음
            if (data < 순회용현재노드.data) {
              if (!순회용현재노드.left) {
                // 현재 순회중인 부모노드의 left 지점에 링크가 null 이면 여기에 새로운노드를 넣어주고
                // 노드가 insert 됬으니 함수를 끝내면 됨.
                순회용현재노드.left = 새로운노드;
                this.데이터수 += 1; // 노드를 추가해줬으니 데이터수도 카운팅한 것
                return;
              }
              // 만약 left가 비어있지 않다면, 이미 이진트리상에서 자리잡은 노드가 있다는 것이니까
              // 함부로 새로운 노드를 넣어주는 게 아니라,
              // 그 밑에 노드로 타고 내려가서 다시 왼쪽 오른쪽을 판단해야 하는거지.
              순회용현재노드 = 순회용현재노드.left; // 위에서 왼쪽노드가 비어있지 않았기 때문에 순회용현재노드가 그 왼쪽노드로 내려온거임.
            }

            // 이번에는 부모노드보다 값이 커서 오른쪽으로 향하는 케이스
            if (data > 순회용현재노드.data) {
              if (!순회용현재노드.right) {
                // 현재 순회중인 부모노드의 right 지점에 링크가 null 이면 여기에 새로운노드를 넣어주고
                // 노드가 insert 됬으니 함수를 끝내면 됨.
                순회용현재노드.right = 새로운노드;
                this.데이터수 += 1; // 노드를 추가해줬으니 데이터수도 카운팅한 것
                return;
              }
              // 만약 right가 비어있지 않다면, 이미 이진트리상에서 자리잡은 노드가 있다는 것이니까
              // 함부로 새로운 노드를 넣어주는 게 아니라,
              // 그 밑에 노드로 타고 내려가서 다시 왼쪽 오른쪽을 판단해야 하는거지.
              순회용현재노드 = 순회용현재노드.right; // 위에서 오른쪽노드가 비어있지 않았기 때문에 순회용현재노드가 그 오른쪽노드로 내려온거임.
            }
          }
        }

        // 현재 이진트리를 깊이우선탐색하는 메서드 -> 스택 구조로 구현해야 함!
        DFS() {
          let 결과값 = []; // 순회한 결과값 (즉, ppt 설명에서 '방문경로'에 해당.)
          let 스택 = [this.root]; // 이 스택에서 계속 pop해서 꺼낼거임. 언제까지? 스택.length가 0이 될때까지!

          // 스택이 0으로 비어버리기 전까지 계속 탐색을 반복하라는 거지 (종결조건)
          while (스택.length !== 0) {
            let current = 스택.pop(); // 이런식으로 스택에서 pop해서 뺀 다음 current 로 넣어줌.

            // 스택에서 빼온 것을 current에 추가하는 순간, current 에 자식노드가 있는지 검색해서 있으면 그거를 스택에 또 추가해 줌.
            if (current.right) {
              // 오른쪽에 자식노드가 있으면 오른쪽 노드 먼저 스택에 push 함
              스택.push(current.right);
            }
            if (current.left) {
              // 왼쪽에 자식노드가 있다면 왼쪽 노드는 나중에 스택에 push함
              스택.push(current.left);
            }

            // 방문경로 배열에 data를 기록해놔서 중복탐색 방지
            // (깊이우선탐색 시 다시 위로 올라가서 부모노드를 탐색하지 않고, 그냥 바로 다음 밑에 노드로 내려가는 거지.)
            결과값.push(current.data);
          }

          return 결과값; // 이진트리의 깊이우선탐색이 끝나면 기록된 방문경로를 리턴해 줌.
        }

        // 현재 이진트리를 너비우선탐색하는 메서드 -> 큐 구조로 구현해야 함!
        // DFS 와 차이점 2개 - 1. 큐 구조를 사용하므로 shift 로 먼저 들어온 노드 순으로 빼온다.
        // 2. 자식노드들을 큐에 push할 때 왼쪽 자식노드부터 확인하고 push한다
        BFS() {
          let 결과값 = []; // 순회한 결과값 (즉, ppt 설명에서 '방문경로'에 해당.)
          let 큐 = [this.root]; // 이 큐에서 계속 shift해서 꺼낼거임. 언제까지? 큐.length가 0이 될때까지!

          // 큐가 0으로 비어버리기 전까지 계속 탐색을 반복하라는 거지 (종결조건)
          while (큐.length !== 0) {
            let current = 큐.shift(); // 이런식으로 큐에서 shift해서 뺀(즉, 먼저 넣은 애들부터 빼도록 하는 것.) 다음 current 로 넣어줌.

            // 큐에서 빼온 것을 current에 추가하는 순간, current 에 자식노드가 있는지 검색해서 있으면 그거를 큐에 또 추가해 줌.
            // DFS 에서는 오른쪽 자식노드 먼저 스택에 push 해줬지만, BFS 에서는 왼쪽 자식노드 먼저 큐에 push 해준다는 것!
            if (current.left) {
              // 왼쪽에 자식노드가 있으면 왼쪽 노드 먼저 큐에 push 함
              큐.push(current.left);
            }
            if (current.right) {
              // 오른쪽에 자식노드가 있다면 오른쪽 노드는 나중에 큐에 push함
              큐.push(current.right);
            }

            // 방문경로 배열에 data를 기록해놔서 중복탐색 방지
            결과값.push(current.data);
          }

          return 결과값; // 이진트리의 너비우선탐색이 끝나면 기록된 방문경로를 리턴해 줌.
        }
      }

      let t = new Tree(5);
      t.insert(3);
      t.insert(8);
      t.insert(1);
      t.insert(4);
      t.insert(6);
      t.insert(9);

      console.log(t.root.data);
      console.log(t.root.left.data);
      console.log(t.root.right.data);
      console.log(t.root.right.right.data);
      console.log(t.root.right.left.data);

      console.log(t.DFS());
      console.log(t.BFS());
    </script>
  </body>
</html>

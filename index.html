<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>알고리즘</title>
  </head>
  <body>
    <script>
      // 병합정렬
      /*
        병합정렬은
        빅-O 로 표기했을 때 O(nlogn) 으로
        어떤 정렬보다도 빠름.

        삽입, 선택 정렬은 반면 O(2의 n제곱)임.

        병합정렬은
        분할 - 정복이 있는데
        이 둘을 따로따로 설명할 것임.
      */
      /*
        아래의 입력값 배열을 기준으로 설명하면,

        분할은
        [5, 10, 66, 77, 54, 32, 11, 15]
        [5, 10, 66, 77], [54, 32, 11, 15]
        [5, 10], [66, 77] [54, 32] [11, 15]
        [5], [10], [66], [77], [54], [32], [11], [15]
        -> 요런 식으로 반으로 쪼갤 수 있을때까지 계속 쪼개는거임.


        정복은
        두 개를 합칠 때, 작은 값이 앞에 오게 해주는거임
        [5, 10], [66, 77], [32, 54], [11, 15]

        이제 이 다음부터가 중요한데, 
        [5, 10], [66, 77] 얘내 둘은 어떻게 합칠 수 있지?
        두 배열의 0번째끼리 비교했을 때, 더 작은 놈이 있는
        배열에서 그 작은 놈을 빼준 다음, 결과값 배열에 넣어줘야 됨.
        그러면 빠진 배열에서는 0번째가 바뀌겠지?
        그럼 그 0번째랑 또 상대 배열의 0번째랑 비교해서
        더 작은 놈을 빼주는거임.

        분할된 배열들                 결과값배열
        [5, 10], [66, 77]             []
        [10], [66, 77]                [5]
        [], [66, 77]                  [5, 10]
        [], []                        [5, 10, 66, 77]
        -> 이때, [66, 77] 은 이미 정렬된 상태이기 때문에, 상대배열이 비어버리게 되면, 
        [66, 77]을 그냥 그대로 끌어와서 결과값 배열로만 가져오면 됨! -> 이런 식으로 합쳐주는 것

        이런식으로 합쳐주면 두 개의 배열로 다시 돌아오고, 얘를 또 똑같이 0번째 애들끼리 비교해서 빼주는거지
        [5, 10, 66, 77], [11, 15, 32, 54]
        [5, 10, 11, 15, 32, 54, 66, 77]
      */
      let 입력값 = [5, 10, 66, 77, 54, 32, 11, 15];

      // 이제 이 병합정렬을 재귀함수를 사용해서 구현해볼거임
      function 병합정렬(입력배열) {
        let 입력배열의길이 = 입력배열.length; // 현재 입력배열의 배열개수를 미리 저장해둔 거
        let 결과값 = []; // 쪼개진 애들을 합쳐서 정복한 결과값을 넣어줄 배열
        if (입력배열의길이 <= 1) {
          // 종결조건이지?
          // 입력배열 길이가 1보다 작다는 건, [] 빈배열이거나, [n] 쪼갤 수 있는데까지 다 쪼갠 케이스니까
          return 입력배열;
        }

        // 현재 입력배열의 어느 지점의 인덱스부터 잘라야 가운데부터 절반으로 자를 수 있는건지
        // 알아야 되니까 중간값을 구해주는 것임.
        // 현재 입력배열의 길이의 절반지점이라 /2 로 구한거고, parseInt 는 정수만 리턴하기 때문에 소수점은 버리니까
        // 정수인 인덱스값을 얻을 수 있겠지
        let 중간값 = parseInt(입력배열의길이 / 2);

        // 중간값을 기준으로 그룹하나 / 그룹둘 이렇게 두 개의 배열로 쪼개주는 것
        let 그룹하나 = 병합정렬(입력배열.slice(0, 중간값)); // 얘는 0번부터 중간값번까지 배열을 잘라서 리턴해 준 것
        let 그룹둘 = 병합정렬(입력배열.slice(중간값)); // 얘는 중간값번부터 마지막번까지 배열을 잘라서 리턴해 준 것

        // 이제 정복을 반복문으로 해보자
        while (그룹하나.length != 0 && 그룹둘.length != 0) {
          // 이 반복문은 두 쪼개진 배열들 모두 최소 하나 이상의 요소는 남아있을 때 도는 거임
          if (그룹하나[0] < 그룹둘[0]) {
            // 그룹하나의 0번째 요소가 더 작으면 걔를 빼줘야한댔지?
            결과값.push(그룹하나.shift()); // 그룹하나의 0번째 요소를 shift 로 빼주고, 그걸 결과값에 push함.
          } else {
            결과값.push(그룹둘.shift()); // 그룹둘의 0번째 요소가 더 작으면 반대로 걔를 빼서 결과값에 넣어주고
          }
        }

        while (그룹하나.length != 0) {
          // 이 반복문은 그룹하나 배열만 원소가 남아있을 경우 도는 반복문
          // -> 즉, 상대배열이 빈배열이 되서 그룹하나가 고대로 결과값 끝부분에 들어가는거
          결과값.push(그룹하나.shift()); // 그룹하나의 0번째 요소를 하나씩 shift 로 빼주고, 그걸 결과값에 push함.
        }

        while (그룹둘.length != 0) {
          // 이 반복문은 그룹둘 배열만 원소가 남아있을 경우 도는 반복문
          // -> 즉, 상대배열이 빈배열이 되서 그룹둘이 고대로 결과값 끝부분에 들어가는거
          결과값.push(그룹둘.shift()); // 그룹둘의 0번째 요소를 하나씩 shift 로 빼주고, 그걸 결과값에 push함.
        }

        // return `그룹하나 : ${그룹하나}, 그룹둘 : ${그룹둘}\n`; // 어떤식으로 쪼개졌는지 콘솔로 확인해보자
        return 결과값;
      }

      console.log(병합정렬(입력값));
    </script>
  </body>
</html>

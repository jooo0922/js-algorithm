<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>알고리즘</title>
  </head>
  <body>
    <script>
      /*
        정렬 알고리즘 이론

        1. 선택정렬

          현재 배열 중에서 가장 작은 애부터 뽑아서
          다른 배열에다 차례로 넣어두는 곳.
          그 다음에는 가장 작은 애가 빠져나가고 남은 배열에서
          또 가장 작은 애를 뽑아서 정렬함.


        2. 삽입정렬

          일단은 현재 배열과 똑같은 순서대로 빼서 넣기 시작함.
          근데 다음에 넣을때, 이전에 빼서 넣은 요소보다 더 작다면,
          이전 요소 앞으로 끼어들고, 더 크다면 이전 요소 뒤로 끼어듦.


        3. 병합정렬

          조금 어려움.
          1. 우선 현재 배열을 반으로 나눔
          2. 각각 나눠진 배열을 또 반으로 나누고, 또 반으로 나눠서
          최소로 나눠진 배열에 값이 1개만 남도록 함.
          그렇게 하면, 나눠진 1개의 값들끼리 누가 더 크고 작은지 비교가 되니까,
          더 작은 놈을 앞으로 오게, 더 큰 놈은 뒤로 가게 하는거지. 
          3. 이제 나눠져서 정렬된 최소 단위의 애들끼리 다시 이어붙임.
          이때, 이어붙이는 애들끼리도 비교해서 다시 정렬해줘야 함. 
          이어붙일 때, 얘를 들어 4개 요소가 들어간 두 개의 배열을 이어붙인다 하면,
          1번 배열과 2번 배열 의 첫번째 요소끼리부터 비교함.
          그래서 더 작은 애가 있다면, 걔를 해당 배열에서 pop 해서
          다른 빈 배열로 옮겨버림. 그래서 젤 작은 놈이 pop 되서 없어진 상태에서
          다시 또 첫번째 요소들끼리 비교하는거.

          -> 두 배열을 이어붙일 때 핵심은 항상 두 배열의 0번째 요소들끼리 비교해서
          더 작은 놈을 pop() 해서 딴데다가 옮겨둔다는 것!


        4. 퀵정렬

          퀵 정렬도 병합이랑 비슷함.
          
          1. 대신 얘는 어느 하나의 기준점이 되는 요소를 정해서
          걔보다 작으면 작은놈들, 크면 큰놈들 이렇게 나눠주고 시작함.

          이런 식으로 요소들을 가운데 특정한 기준점을 기준으로
          나누고 나누고 나눠서 더 이상 나눌 수 없을 때까지 나눔

          2. 다 나누고 나서 이제 다시 합쳐줌
          근데 이때는 나보다 작은 건 무조건 내 앞에 있고,
          큰건 무조건 내 뒤에 있으니까
          작은건 앞에 합치고, 큰건 뒤에 합치는 것이지
          -> 이렇게 이어붙이면 정렬된 배열을 얻게 됨.
      */
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>알고리즘</title>
  </head>
  <body>
    <script>
      /*
        재귀함수

        내가 나를 호출하는 함수 (requestAnimationFrame?)
        
        반복문 <-> 재귀함수 서로 호환이 됨
        그래서 반복문으로 표현할 수 있는 것들은
        재귀함수로 표현할 수 있고, 
        재귀함수로 표현할 수 있는 것들도
        반복문으로 표현할 수 있음.

        이번 강의에서는 반복문으로 1부터 100까지 숫자들 합 & 곱 
        을 구하는 알고리즘을 할거임.

        일단 반복문 먼저 살펴보고,
        그걸 재귀함수로 변경하는 방법도 다음에
        설명해준다고 함.

        즉,
        s = s + 1
        s = s + 2
        s = s + 3
        s = s + 4
        s = s + 5 
        ...
        s = s + 100
        이것의 결과값과
        s = s * 1
        s = s * 2
        s = s * 3
        s = s * 4
        s = s * 5 
        ...
        s = s * 100
      이것의 결과값을 구하라는 뜻.
      */
      let s = 0;
      for (let i = 1; i < 101; i++) {
        s += i;
      }
      console.log(s); // 이거는 덧셈의 결과값

      let n = 100;
      console.log((n * (n + 1)) / 2); // 1부터 100까지의 합 구하는 법은 이런 공식으로도 정형화되어 있음.
      /*
      그렇다면 얘는

      let n = 100
      for (let i = 1; i < n + 1; i++) {
        n += i;
      }
      console.log(n);

      이렇게도 표현할 수가 있을거임.
      이거를 소위 Big O 표기법으로
      O(n) 이라고 표현함.

      즉, 저 n의 값이 커지면 커질수록 for 루프의 반복횟수가 증가함.

      근데 
      (n * (n + 1)) / 2 
      요런거는 반복 안하고 한번만 계산해줘도 결과값이 딱 나오지?
      이런거는 O(1) 이렇게 표기함.
      즉, 반복을 한 번만 한다는거지.

      그래서, 가급적 모든 코딩테스트를 풀때
      1번만 반복해서 풀 수 있는 공식이 없는지
      먼저 찾아보는 게 좋음!
      Big O 가 낮을수록 효율 차이가 많이 날테니까
      */

      let m = 1; // 곱셈은 1 * 머머머 이런식으로 시작해줘야 하니 처음 시작값을 1로 줘야됨.
      for (let i = 1; i < 6; i++) {
        m *= i;
      }
      console.log(m); // 이거는 곱셈의 결과값

      // 이번에는 재귀함수로 구해보자
      /*
        재귀함수로 구할때는
        1부터 반복 시작이 아닌
        100부터 반복 시작을 해줄거임
        
        순번    f(n)      n     return         최종 (결국 f(n)으로 호출한 리턴값들이 각각의 n에 더해지도록 반복되는 재귀함수인 것이지!)
        1       f(100)   100   100 + f(99)     100+99+98+97+96+95+94...+2+1
        2       f(99)    99    99 + f(98)      99+98+97+96+95+94...+2+1
        3       f(98)    98    98 + f(97)      98+97+96+95+94...+2+1
        4       f(97)    97    97 + f(96)      97+96+95+94...+2+1
        ...     
        2       f(2)     2     2 + f(1)        2+1
        1       f(1)     1     1 
        -> 드디어 마지막 반복문에서 리턴값이 자기자신(즉 n)을 호출하지 않는 상황이 옴.
        요런거를 '종렬조건' 즉, 끝내는 조건이라고 하는데, 재귀함수는 종렬조건이 무조건 있어야 함.
        없으면 무한반복됨.

        반복문은 1부터 시작해서 100까지 가는데
        재귀함수는 100에서 출발해서 1에서 멈추지?
      */
      function f1(n) {
        if (n <= 1) {
          // 종렬조건
          return 1;
        }

        return n + f1(n - 1);
      }
      console.log(`재귀함수 덧셈결과값: ${f1(100)}`);

      // 이번에는 재귀함수로 곱셈을 구해보자
      /*
        이번에는 1부터 5까지의 곱만 구해보자
        
        순번    f(n)      n     return         최종 (결국 f(n)으로 호출한 리턴값들이 각각의 n에 곱해지도록 반복되는 재귀함수인 것이지!)
        1       f(5)     5      5 * f(4)       5 * 4 * 3 * 2 * 1
        2       f(4)     4      4 * f(3)       4 * 3 * 2 * 1
        3       f(3)     3      3 * f(2)       3 * 2 * 1
        4       f(2)     2      2 * f(1)       2 * 1  
        1       f(1)     1      1 -> 종렬값
      */
      function f2(n) {
        if (n <= 1) {
          // 종렬조건
          return 1;
        }

        return n * f2(n - 1);
      }
      console.log(`재귀함수 곱셈결과값: ${f2(5)}`);
    </script>
  </body>
</html>

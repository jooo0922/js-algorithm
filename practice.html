<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>연습문제</title>
  </head>
  <body>
    <script>
      // 그림자연결
      /*
        이진트리를 깊이우선탐색으로 내려와서 해결하는 문제.

        간선의 길이를 이진트리 노드로 표현할 때,
        중복과 순서를 허용하지 않는
        js의 Set 객체를 활용할 것.

        아래 graph 객체에서
        key는 간선의 길이를 표현한 이진트리 상에서 각 노드에 담긴 데이터(간선 길이 비율을 100으로 곱한 값)를 의미하고,
        value 각 간선길이 노드에 연결되어있는 다른 간선길이 노드들의 데이터가 담겨있음.
      */
      graph = {
        100: new Set([67, 66]),
        67: new Set([100, 82, 63]),
        66: new Set([100, 73, 69]),
        82: new Set([67, 61, 79]),
        63: new Set([67]),
        73: new Set([66]),
        69: new Set([66, 65, 81]),
        61: new Set([82]),
        79: new Set([82, 87, 77]),
        65: new Set([69, 84, 99]),
        81: new Set([69]),
        87: new Set([79, 31, 78]),
        77: new Set([79]),
        84: new Set([65]),
        99: new Set([65]),
        31: new Set([87]),
        78: new Set([87]),
      };

      function 깊이우선탐색최댓값(graph, start) {
        let 방문 = []; // 이미 방문한 노드들을 담아놓을 배열 (중복방지)
        let stack = [start]; // 깊이우선 탐색은 항상 stack 자료구조를 사용해야 한다고 했지? 또 맨 처음 노드인 start 노드는 루트노드로 초기값으로 넣어주고.

        while (stack) {
          let n = 0; // 매 반복문마다 다음 방문 노드를 넣어줄 변수
          n = stack.pop(); // stack에 있는 last in 요소를 꺼내서 first out 으로 pop 해서 다음방문노드를 꺼내줌.

          if (!방문.includes(n)) {
            // 이제 방문하려는 노드가 이미 방문한 노드 배열에 없다면, 방문을 새로 해야겠지?
            // 그래서 방문에다가 새롭게 push를 해주는거임.
            방문.push(n);

            /*
              이거는 일단 뭐냐면,
              지금 방문하려는 노드에 연결된 노드들
              (위에 graph에 보면, 예를 들어 67: new Set([100, 82, 63])
              이렇게 되어있는데, 이게 뭔 뜻이냐면 67이라는 노드에 연결된
              모든 노드들을 순서 관계없이, 중복 없이 Set 으로 나열해서 할당해놨다는 거임.
              그런데, 100은 67에 연결된 노드이기는 하나 부모노드잖아?
              
              깊이 우선 탐색에서는 부모노드로 돌아가지 않잖아
              그니까 부모노드는 빼야지. 뭘로? Set 으로 차집합을 구하는 연산을 사용해서!
              
              이때,[...graph(n)] 이거는, 전개구문을 사용해서
              Set 객체 안의 요소들을 모두 펼쳐서 하나의 배열로 만드는거고,
              이 새로만든 연결된 노드들 배열요소 중에서, '방문' 배열에 존재하는 기존의 노드들과 겹치는 게 있는지
              new Set(방문).has(연결된노드) 로 체크하는거임.
              
              그렇게 해서 이미 방문하지 않은 노드들만 filter로 걸러서
              새로운 배열로 리턴해주고, 그 배열로 Set 을 최종적으로 만들어서 차집합을 만들어 냄.)
            */
            let 차집합 = new Set(
              [...graph[n]].filter(
                (연결된노드) => !new Set(방문).has(연결된노드)
              )
            );

            if ([...차집합].length === 0) {
              // 차집합이 존재하지 않는다면, 즉 자식노드가 더이상 엎다면
              // 깊이우선 탐색 중단함
              break;
            }

            // 깊이우선탐색으로 '최댓값'을 찾는 거니까
            // 지금 방문하려는 노드의 자식노드들 중에서 더 큰값만 선택해서 먼저 stack 에 push해줘야 함.
            stack.push(Math.max(...차집합));

            // console.log(`방문: ${방문}`);
            // console.log(`stack: ${stack}`);
          }

          if (stack.length === 0) {
            break; // stack 이 비어있으면 더이상 깊이우선탐색을 반복할 필요가 없음
          }
        }

        return 방문;
      }

      function 깊이우선탐색최솟값(graph, start) {
        let 방문 = []; // 이미 방문한 노드들을 담아놓을 배열 (중복방지)
        let stack = [start]; // 깊이우선 탐색은 항상 stack 자료구조를 사용해야 한다고 했지? 또 맨 처음 노드인 start 노드는 루트노드로 초기값으로 넣어주고.

        while (stack) {
          let n = 0; // 매 반복문마다 다음 방문 노드를 넣어줄 변수
          n = stack.pop(); // stack에 있는 last in 요소를 꺼내서 first out 으로 pop 해서 다음방문노드를 꺼내줌.

          if (!방문.includes(n)) {
            // 이제 방문하려는 노드가 이미 방문한 노드 배열에 없다면, 방문을 새로 해야겠지?
            // 그래서 방문에다가 새롭게 push를 해주는거임.
            방문.push(n);

            /*
              이거는 일단 뭐냐면,
              지금 방문하려는 노드에 연결된 노드들
              (위에 graph에 보면, 예를 들어 67: new Set([100, 82, 63])
              이렇게 되어있는데, 이게 뭔 뜻이냐면 67이라는 노드에 연결된
              모든 노드들을 순서 관계없이, 중복 없이 Set 으로 나열해서 할당해놨다는 거임.
              그런데, 100은 67에 연결된 노드이기는 하나 부모노드잖아?
              
              깊이 우선 탐색에서는 부모노드로 돌아가지 않잖아
              그니까 부모노드는 빼야지. 뭘로? Set 으로 차집합을 구하는 연산을 사용해서!
              
              이때,[...graph(n)] 이거는, 전개구문을 사용해서
              Set 객체 안의 요소들을 모두 펼쳐서 하나의 배열로 만드는거고,
              이 새로만든 연결된 노드들 배열요소 중에서, '방문' 배열에 존재하는 기존의 노드들과 겹치는 게 있는지
              new Set(방문).has(연결된노드) 로 체크하는거임.
              
              그렇게 해서 이미 방문하지 않은 노드들만 filter로 걸러서
              새로운 배열로 리턴해주고, 그 배열로 Set 을 최종적으로 만들어서 차집합을 만들어 냄.)
            */
            let 차집합 = new Set(
              [...graph[n]].filter(
                (연결된노드) => !new Set(방문).has(연결된노드)
              )
            );

            if ([...차집합].length === 0) {
              // 차집합이 존재하지 않는다면, 즉 자식노드가 더이상 엎다면
              // 깊이우선 탐색 중단함
              break;
            }

            // 깊이우선탐색으로 '최솟값'을 찾는 거니까
            // 지금 방문하려는 노드의 자식노드들 중에서 더 작은 값만 선택해서 먼저 stack 에 push해줘야 함.
            stack.push(Math.min(...차집합));

            // console.log(`방문: ${방문}`);
            // console.log(`stack: ${stack}`);
          }

          if (stack.length === 0) {
            break; // stack 이 비어있으면 더이상 깊이우선탐색을 반복할 필요가 없음
          }
        }

        return 방문;
      }

      // start node 가 100 즉, 이진트리 최상단의 루트노드인 것이지.
      let 결과값_깊이우선탐색최댓값 = 깊이우선탐색최댓값(graph, 100);
      console.log(결과값_깊이우선탐색최댓값); // 깊이우선탐색으로 더 큰 값만 방문한 배열을 리턴받음 -> 이게 첫번째 정답
      // 이렇게 위에서 깊이우선탐색으로 받은 두 숫자 배열들을 이용해서 아스키코드를 찾아볼거임
      let result = "";
      for (const v of 결과값_깊이우선탐색최댓값) {
        result += String.fromCharCode(v);
      }
      console.log(result);

      let 결과값_깊이우선탐색최솟값 = 깊이우선탐색최솟값(graph, 100);
      console.log(결과값_깊이우선탐색최솟값); // 깊이우선탐색으로 더 작은 값만 방문한 배열을 리턴받음 -> 이게 두번째 정답
      // 이렇게 위에서 깊이우선탐색으로 받은 두 숫자 배열들을 이용해서 아스키코드를 찾아볼거임
      let result2 = "";
      for (const v of 결과값_깊이우선탐색최솟값) {
        result2 += String.fromCharCode(v);
      }
      console.log(result2);
    </script>
  </body>
</html>
